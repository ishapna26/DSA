Java Collections Framework:
---------------------------
- Collection is basically an interface (Set of methods / properties that defines the behaviour of the class).
- It was developed inorder for the end users to use java easily.

LIST IMPLEMENTATIONS:
--------------------
--------------------
1. ArrayList: It is the advanced version of arrays in java.
   Syntax:  " ArrayList<DataType> a =new ArrayList<>(); "

* It has a lot of inbuilt methods that can be accessed using (.) operator to manipulate or put to use.
* Popular methods: 
                size(), get(), remove(), add(), contains()

Example Program 1:
----------------
import java.util.*;

class Main3{
	public static void main(String[] args) {
		
		ArrayList <String> name=new ArrayList<>();
		name.add("Shapna");
		name.add("Lucy");
		name.add("Mark");
		
		for(int i=0;i<name.size();i++) {
			System.out.print(name.get(i)+" ");
		}
	}
}



2. LinkedList: (Resizable array / Dynamic array) - where the values can be added from both the sides ie. Rear and Front. It can hold different types of data.
   Syntax: " LinkedList <DataType> a=new LinkedList<>(); "

* Popular Methods: size(), add(), addFirst(), addLast(), removeFirst(), removeLast()

Example Program 1:
-----------------
import java.util.*;

class Main3{
	public static void main(String[] args) {
		LinkedList<Data> link =new LinkedList<>();
		Data data=new Data("shapna",21,"cse",24.0f);
		link.add(data);
		System.out.println(link.get(0));

	}
}
class Data {
	String name;
	int age;
	String dept;
	float roll;

	Data(String name, int age, String dept, float roll){
		this.name = name;
		this.age = age;
		this.dept = dept;
		this.roll = roll;	
	}

	@Override
	public String toString() {
		return "Name: " + name + ", Age: " + age + ", Dept: " + dept + ", Roll: " + roll;
	}
}

3. Stack : It is used to store elements in which the elements can be accessed using LIFO (Last In First Out) Principle. It " extends Vector interface "
   Syntax: " Stack <DataType> a=new Stack<>(); "

* Methods: push(), pop(), peak() - top element, setSize() - set the size of the stack

Example Program 1:
-----------------
import java.util.*;

class Main3{
	public static void main(String[] args) {
		
		Stack<String> name=new Stack<>();
		name.push("Allie Milton");
		name.push("Benjamin");
		name.push("Carlise");
		for(int i=0;i<name.size();i++) {
			System.out.println(name.get(i));
		}
	}
}

4. Vector: similar to ArrayList -> can be used when you want a thread safe implementation (ie. can handle race condition: multiple people accessing and modifying the list)

import java.util.*;
class Main7{
	public static void main(String[] args) {
		
		Vector<Integer>v=new Vector<>();
		v.add(1);
		v.add(2);
		
		for(int i=0;i<v.size();i++) {
			System.out.print(v.get(i));
		}
	}
}

SET IMLEMENTATION 
-----------------
-----------------
Three main types of set: 1. HashSet 2. LinkedHashSet 3. TreeSet ---> No sets allows duplicate elements.
Syntax: 
Set<DataType> set=new HashSet<>, Set<DataType> set=new HashSet<>, Set<DataType> set=new TreeSet<>

1. HashSet: Here no guarantee of ordering. 
2. LinkedHashSet: Here elements are stored in an order.
3. TreeSet: Here elements will be stored in a sorted order.

xxx Set dont have get method xxx
- because set is not ordered by index
- You can access the element by:

1. for(int num: set){
   System.out.println(num);
}

2. using iterator class

Iterator<String> iterator = set.iterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}


QUEUE IMPLEMENTATION: Like set queue also dont have get() method beacuse they are order based and not based on index.
--------------------
--------------------
The elements inside the queue can be accessed using FIFO principle.
1. queue : Queue<Datatype> queue=new LinkedList<>()
2. ArrayDeque: ArrayDeque<Datatype> deque=new ArrayDeque<>(); [offer(), offerFirst(), offerLast(), add(), peek(), poll()]
3. PriorityDeque: PriorityQueue<Datatype> pq=new PriorityQueue<>();
   -It retrieves the value in ascending order (By internal structure it stores values in a way how we gave the input but only when retrieving it prints in ascending order).


| Method      | Description                          | Throws Exception? |
| ----------- | ------------------------------------ | ----------------- |
| `peek()`    | Returns the head without removing it | ❌ No              |
| `element()` | Returns the head without removing it | ✅ Yes (if empty)  |
| `poll()`    | Returns and removes the head         | ❌ No              |
| `remove()`  | Returns and removes the head         | ✅ Yes (if empty)  |


HASHMAPS: no order is maintained in hasmap
---------
---------
1. Maps have key value pairs
2. The keys should be unique

import java.util.*;

class Main7{
	public static void main(String[] args) {
		
		HashMap<Integer,String> data=new HashMap<>();
		
		data.put(1,"Allie");
		data.put(2,"Bob");
		data.put(3,"Carie");
		data.put(4,"Daniel");
		data.put(5,"Emma");
		
		System.out.println(data);
		System.out.println(data.get(5));	
	}
}

output:
{1=Allie, 2=Bob, 3=Carie, 4=Daniel, 5=Emma}
Emma

- We also have TreeMap (maintains order unlike hashmap)

